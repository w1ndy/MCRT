#version 430 core

layout(binding = 0, rgba32f) uniform image2D framebuffer;

uniform vec3 eye;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec2 sample_offset;
uniform int frame;

#define MAX_SCENE_BOUNDS    100.0
#define EPS                 0.000001

const vec3 lightpos = vec3(-1.5, -1.5, 2.5);

const vec3 intensity = vec3(0.8, 0.8, 0.8);
const vec3 ambient = vec3(0.2, 0.2, 0.2);
const vec3 specular = vec3(0.75, 0.75, 0.75);

struct bbox_t
{
	vec3 vmin;
	vec3 vmax;
};

struct group_t
{
    int vptr;
    int nptr;
    int num_vertices;
    int material_id;
};

struct material_t
{
	vec3 Kd;
	vec3 Ka;
	vec3 Ks;
	float Ns;
	float Tr;
};

layout(std430, binding = 1) buffer Materials
{
    material_t materials[];
};

layout(std430, binding = 2) buffer BoundingBoxes
{
    bbox_t bboxes[];
};

layout(std430, binding = 3) buffer Groups
{
    group_t groups[];
};

layout(std430, binding = 4) buffer Vertices
{
    float vertices[];
};

const int MAX_TRACE = 4;

struct hitinfo_t
{
    float t;
    int target;
};

struct trace_state_t
{
    vec3 origin;
    vec3 dir;
    vec3 color;
    hitinfo_t h;
    vec3 hit;
    vec3 Ld;
    vec3 N;
};

bool vec3GreaterThan(vec3 a, vec3 b)
{
    return (a.x > b.x && a.y > b.y && a.z > b.z);
}

bool intersectBoundingBox(vec3 origin, vec3 dir, bbox_t bbox)
{
    if (vec3GreaterThan(origin, bbox.vmin) && vec3GreaterThan(bbox.vmax, origin))
        return true;
    vec3 tMin = (bbox.vmin - origin) / dir;
    vec3 tMax = (bbox.vmax - origin) / dir;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return (tNear > 0.0 && tNear < tFar);
}

bool isIntersected(vec3 origin, vec3 dir, out hitinfo_t h)
{
	h.t = MAX_SCENE_BOUNDS;
	for (int i = 0; i < groups.length(); i++) {
		if (intersectBoundingBox(origin, dir, bboxes[i])) {
			return true;
		}
	}
}

vec3 trace(vec3 origin, vec3 dir)
{
	hitinfo_t h;
	if (isIntersected(origin, dir, h)) {
		return vec3(1.0, 1.0, 1.0);
	}
	return vec3(0, 0, 0);
}

layout(local_size_x = 16, local_size_y = 8) in;
void main(void)
{
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(framebuffer);
    if (pix.x >= size.x || pix.y >= size.y) {
        return;
    }

    vec2 pos = vec2(pix.x + 0.5 + sample_offset.x, pix.y + 0.5 + sample_offset.y) / vec2(size.x - 1, size.y - 1);
    vec3 dir = mix(mix(ray00, ray01, pos.y), mix(ray10, ray11, pos.y), pos.x);
    vec3 color = trace(eye, normalize(dir));

	imageStore(framebuffer, pix, vec4(1.0, 1.0, 1.0, 1.0));
    //imageStore(framebuffer, pix, mix(imageLoad(framebuffer, pix), vec4(color.rgb, 1.0), 1.0 / float(frame)));
}